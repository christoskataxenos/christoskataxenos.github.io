---
title: "ANSI C vs Python: Ο Διχασμός της Προσωπικότητας στις ΓΕ2"
date: "2026-01-10"
description: "Το απόλυτο recap των δεύτερων εργασιών (ΠΛΗ10 & ΠΛΗΠΡΟ). Από τον εφιάλτης του Bead Sort στην C89, στην λύτρωση των Dictionaries της Python."
tags: ["eap", "plh10", "plhpro", "c", "python", "devlog", "assignments"]
---

<Stats panicLevel={85} coffeeCups={16} hoursSpent={55} />

Λοιπόν, επιτέλους ανάσα. Παρέδωσα και τις δύο δεύτερες Γραπτές Εργασίες (ΓΕ2) για ΠΛΗ10 και ΠΛΗΠΡΟ, και νιώθω σαν να βγήκα από χρονοντούλαπο.

Για να είμαστε τυπικοί, στο **Ελληνικό Ανοικτό Πανεπιστήμιο (ΕΑΠ)** έχουν έναν μοναδικό τρόπο να μας κρατάνε σε εγρήγορση (ή σε μόνιμο πανικό, εξαρτάται πώς το βλέπεις). Αυτή η φορά όμως, η εμπειρία είχε κάτι από ταινία επιστημονικής φαντασίας... γυρισμένη στο 1989, με εμβόλιμα πλάνα από το 2026.

## ΠΛΗ10: Επιστροφή στο Μέλλον (με ANSI C)

Ας ξεκινήσουμε με το "κυρίως πιάτο" του πόνου. Έχουμε 2026. Η τεχνολογία τρέχει, η AI γράφει ποίηση, και εμείς στην ΠΛΗ10 πρέπει να γράφουμε σε **ANSI C (C89)**.

Ναι, καλά διαβάσατε. Μας ζητάνε να γράφουμε C λες και είμαστε στο Back to the Future με τον Marty McFly. Ξέχνα το να δηλώσεις μεταβλητή μέσα στο `for loop`. Απαγορεύεται. Όλα πάνω-πάνω, νοικοκυρεμένα, όπως το '89.

<Terminal title="gcc terminal">
error: 'for' loop initial declarations are only allowed in C99 or C11 mode
note: use option -std=c99, -std=gnu99, -std=c11 or -std=gnu11 to compile your code
</Terminal>

Ορίστε η διαφορά που μας έκανε τη ζωή δύσκολη:

```c
/* Modern C (Πως θα έπρεπε να είναι) */
for (int i = 0; i < 10; i++) {
    printf("%d", i);
}

/* ANSI C (Πως το θέλει το ΕΑΠ) */
int i; /* Πρέπει να δηλωθεί στην αρχή του block αλλιώς τρως error */

for (i = 0; i < 10; i++) {
    printf("%d", i);
}
```

### ANSI C vs Python: Η Σύγκριση

Για να καταλάβετε το πολιτισμικό σοκ, δείτε τη διαφορά στην ίδια λειτουργία:

<ComparisonTable 
  headers={["Feature", "ANSI C (C89)", "Modern Python"]}
  rows={[
    ["Variable Declaration", "Υποχρεωτικά στην αρχή του block", "Οπουδήποτε (on the fly)"],
    ["Comments", "Μόνο /* block */", "# line (single line)"],
    ["For Loops", "int i; for(i=0; i<n; i++)", "for i in range(n):"],
    ["Reading Files", "15+ γραμμές (fopen, check, loop, fclose)", "data = open('file.txt').read()"],
    ["Mental Health", "📉 Hard Reset", "📈 Zen Mode"]
  ]}
/>

<Callout type="danger" title="The Pedantic Trap">
Αν γράφετε C για το ΕΑΠ, προσοχή στα comments! Το `//` εισήχθη επίσημα στην C99. Αν το χρησιμοποιήσετε και ο καθηγητής τρέξει τον compiler με το flag `-ansi -pedantic`, η εργασία σας μπορεί να γεμίσει warnings ή errors πριν καν ξεκινήσει η διόρθωση. Χρησιμοποιείτε μόνο `/* ... */`.
</Callout>

### Το μαρτύριο του Bead Sort

Και σα να μην έφτανε η γλώσσα, είχαμε και τα θέματα.

1.  **Κύβοι vs Τετράγωνα:** Να αποδείξουμε αν $1^3 + ... + N^3 = (1+...+N)^2$. Εύκολο; Ναι. Αλλά έπρεπε να το γράψουμε ΚΑΙ σε Ψευδοκώδικα ΚΑΙ σε C, με ελέγχους αν το $N$ είναι μεταξύ 100 και 300.
2.  **Bead Sort (Gravity Sort):** Εδώ έκλαψαν μανούλες. Έπρεπε να προσομοιώσουμε χάντρες που πέφτουν σε έναν άβακα. Στην C. Με πίνακες. Χωρίς dynamic memory allocation.

<Callout type="warning" title="Logic Error">
Το να προσπαθείς να μετρήσεις "κοντάρια" και να γεμίζεις τον πίνακα `counts` ενώ παλεύεις με δείκτες πινάκων, είναι μια μορφή βασανιστηρίου που δεν καλύπτεται από τη Συνθήκη της Γενεύης.
</Callout>

3.  **Cities Matrix:** Πίνακας αποστάσεων πόλεων, όπου διαβάζαμε μόνο το πάνω δεξιά τρίγωνο (αφού η απόσταση Α->Β είναι ίδια με Β->Α). Τουλάχιστον αυτό δούλεψε χωρίς segfaults, αφού "καθρεφτίσαμε" τις τιμές στο κάτω μέρος.

## Ο Ψευδοκώδικας και η Διπολική Διαταραχή

Κάποιος πρέπει να μου εξηγήσει τη λογική του να γράφουμε την *ίδια* ακριβώς άσκηση δύο φορές. Μία σε C και μία σε Ψευδοκώδικα.

Το αστείο είναι ότι πιάνεις τον εαυτό σου να κάνει debug στον ψευδοκώδικα. "Ναι, αλλά εδώ το βελάκι ανάθεσης `<-` είναι σωστό ή μήπως έπρεπε να βάλω άνω-κάτω τελεία;". Λεπτομέρειες που σου τρώνε τη ζωή, ενώ ο compiler της C απλά γελάει μαζί σου.

## ΠΛΗΠΡΟ: Η Σωτηρία (Python)

Ευτυχώς, η δεύτερη εργασία της ΠΛΗΠΡΟ ήταν το βάλσαμο στην πληγή. Μετά από 48 ώρες με δηλώσεις μεταβλητών στην αρχή της συνάρτησης και "κυνήγι" των structs, το να γράφεις Python έμοιαζε με το να βγάζεις τα στενά παπούτσια μετά από 10 χιλιόμετρα περπάτημα.

### Slicing, Sets και Βιβλιοθήκες

Εδώ τα πράγματα ήταν πιο πολιτισμένα:

* **Strings & Sets:** Κάναμε slicing strings ανάποδα (`s[::-1]`) και βρήκαμε βιβλία που ανήκουν "είτε στη μία κατηγορία είτε στην άλλη αλλά όχι και στις δύο" με ένα απλό `^` (Symmetric Difference). Στην C θα έγραφα ακόμα loops για αυτό.
* **Triangle Inspector:** Υπολογισμός εμβαδού με τύπο του Ήρωνα. `import math` και καθάρισες.
* **Library System:** Το μεγάλο project. Λεξικά μέσα σε λεξικά (`Library` dict, `vathmologies` dict).

Το αγαπημένο μου σημείο; Η διαχείριση της επιστροφής βιβλίου, όπου έπρεπε να αναγκάσουμε τον χρήστη να δώσει βαθμολογία 1-5.

```python
# Η ομορφιά του Pythonic input validation
while True:
    rating_str = input("Δώσε βαθμολογία για το βιβλίο (1-5): ").strip()
    try:
        rating = int(rating_str)
        if 1 <= rating <= 5:
            break
        else:
            print("Η βαθμολογία πρέπει να είναι ακέραια μεταξύ 1 και 5.")
    except ValueError:
        print("Μη έγκυρη βαθμολογία.")
```

<FileTree>
- final_submission
  - plh10_c_pain
    - main.c (C89 legacy code)
    - katarapsevdokodikas.eap (Γιατί;)
  - plhpro_python_joy
    - library_system.py (Clean code)
    - utils.py
</FileTree>

## Συμπέρασμα
Οι ΓΕ2 ήταν ένα μάθημα υπομονής και σχιζοφρένειας.

Στην ΠΛΗ10 έμαθα πώς να σκέφτομαι σαν computer του 1990 και πώς να διαχειρίζομαι τη μνήμη (και τα νεύρα μου).

Στην ΠΛΗΠΡΟ έμαθα πώς να λύνω προβλήματα γρήγορα και κομψά, εκτιμώντας τις σύγχρονες γλώσσες.

Η διαφορά στην ψυχική υγεία είναι μετρήσιμη σε κούπες καφέ. Αν επιβίωσα από τον συνδυασμό Bead Sort σε C και Library Management σε Python την ίδια εβδομάδα, τίποτα δεν μπορεί να με σταματήσει.

Αν νομίζετε ότι η ANSI C ήταν το μόνο πρόβλημα αυτής της ενότητας, ρίξτε μια ματιά και στο πώς το [plh10.exe διέλυσε το VS Code μου](/blog/human-vs-compiler) στην προηγούμενη εργασία.

Πάμε για τις ΓΕ3 τώρα. Με περισσότερο καφέ και λιγότερα Segmentation Faults (ελπίζω).
